package protocol

import (
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"log"
	"math/big"
	"os"
	"path/filepath"
	"time"
)

// TODO: Take more care to isolate out logic, that way your code is actually modular and can be reused easily

// Generate a 4096-bit RSA keypair and a Grumble auto-generated X509
// certificate. Output PEM-encoded DER representations of the resulting
// certificate and private key to certificatePath and keyPath.
func GenerateCertificate(certificatePath, keyPath string) (err error) {
	// TODO: use lets encrypt to generate real certs, or tor, fuck self signed certs, or just use a fucking ecdsa key like a nroaml person
	// TODO: At least make it optional to be self signed or legit
	now := time.Now()
	template := &x509.Certificate{
		SerialNumber: big.NewInt(0),
		Subject: pkix.Name{
			CommonName: "Mumble Autogenerated Certificate",
		},
		NotBefore: now.Add(-300 * time.Second),
		// Valid for 1 year.
		// TODO: Why?
		NotAfter: now.Add(24 * time.Hour * 365),

		// TODO: Can't be proper
		SubjectKeyId: []byte{1, 2, 3, 4},
		KeyUsage:     x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
	}

	keyPair, err := rsa.GenerateKey(rand.Reader, 4096)
	if err != nil {
		return err
	}

	certificateBuffer, err := x509.CreateCertificate(rand.Reader, template, template, &keyPair.PublicKey, keyPair)
	if err != nil {
		log.Printf("Error: %v", err)
		return err
	}
	certificateBlock := pem.Block{
		Type:  "CERTIFICATE",
		Bytes: certificateBuffer,
	}

	privateKey := x509.MarshalPKCS1PrivateKey(keyPair)
	keyBlock := pem.Block{
		Type:  "RSA PRIVATE KEY",
		Bytes: privateKey,
	}

	// TODO: Why would a file for generating cert require arguments? use the fucking config, apply args to config in the COMMAND
	certificateFilename := filepath.Join(certificatePath, "cert.pem")
	certificateFile, err := os.OpenFile(certificateFilename, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0700)
	if err != nil {
		return err
	}
	defer certificateFile.Close()
	err = pem.Encode(certificateFile, &certificateBlock)
	if err != nil {
		return err
	}

	keyFilename := filepath.Join(certificatePath, "key.pem")
	keyFile, err := os.OpenFile(keyFilename, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0700)
	if err != nil {
		return err
	}
	defer keyFile.Close()
	err = pem.Encode(keyFile, &keyBlock)
	if err != nil {
		return err
	}

	return nil
}
